const localList = require('./lang.json').words;
const baseList = require('badwords-list').array;
const unidecode = require('unidecode');
class Filter {

  /**
   * Filter constructor.
   * @constructor
   * @param {object} options - Filter instance options
   * @param {boolean} options.emptyList - Instantiate filter with no blacklist
   * @param {array} options.list - Instantiate filter with custom list
   * @param {string} options.placeHolder - Character used to replace profane words.
   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.
   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.
   * @param {string} options.splitRegex - Regular expression used to split a string into words.
   */
  constructor(options = {}) {
    Object.assign(this, {
      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),
      exclude: options.exclude || [],
      splitRegex: options.splitRegex || /\b/,
      placeHolder: options.placeHolder || '*',
      regex: options.regex || /[^a-zA-Z0-9|\$|\@]|\^/g,
      replaceRegex: options.replaceRegex || /\w/g
    })
  }

  /**
   * Determine if a string contains profane language.
   * @param {string} string - String to evaluate for profanity.
   */

  // chèn thêm

  /**
   * Remove diacritics (accents) from a string
   * @param {string} string - String to remove diacritics from.
   */
  removeDiacritics(string) {
    return unidecode(string);
  }

  /**
   * Determine if a string contains profane language.
   * @param {string} string - String to evaluate for profanity.
   */
  isProfane(string) {
    const noDiacriticsString = this.removeDiacritics(string);
    return this.list
      .map(word => this.removeDiacritics(word)) // remove diacritics from each word in the list
      .filter((word) => {
        const wordExp = new RegExp(`\\b${word.replace(/(\W)/g, '\\$1')}\\b`, 'gi');
        return !this.exclude.includes(word.toLowerCase()) && wordExp.test(noDiacriticsString);
      })
      .length > 0 || false;
  }

  // kết thúc chèn thêm

  // isProfane(string) {
  //   return this.list
  //     .filter((word) => {
  //       const wordExp = new RegExp(`\\b${word.replace(/(\W)/g, '\\$1')}\\b`, 'gi');
  //       return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);
  //     })
  //     .length > 0 || false;
  // }

  /**
   * Replace a word with placeHolder characters;
   * @param {string} string - String to replace.
   */
  replaceWord(string) {
    return string
      .replace(this.regex, '')
      .replace(this.replaceRegex, this.placeHolder);
  }

  /**
   * Evaluate a string for profanity and return an edited version.
   * @param {string} string - Sentence to filter.
   */

  // clean của hàm

  // clean(string) {
  //   return string.split(this.splitRegex).map((word) => {
  //     return this.isProfane(word) ? this.replaceWord(word) : word;
  //   }).join(this.splitRegex.exec(string)[0]);
  // }

  // clean tự tạo
  clean(string) {
    const words = string.split(/\s+/); // Phân tách các từ bằng khoảng trắng
    const cleanWords = words.map((word) => {
      // Loại bỏ các dấu câu không cần thiết
      const cleanedWord = word.replace(/[^a-zA-Z0-9\u00C0-\u024F]/g, '');
  
      return this.isProfane(cleanedWord) ? this.replaceWord(word) : word;
    });
  
    return cleanWords.join(' '); // Kết hợp các từ lại với dấu cách
  }
  
  // kết thúc clean tự tạo

  /**
   * Add word(s) to blacklist filter / remove words from whitelist filter
   * @param {...string} word - Word(s) to add to blacklist
   */
  addWords() {
    let words = Array.from(arguments);

    this.list.push(...words);

    words
      .map(word => word.toLowerCase())
      .forEach((word) => {
        if (this.exclude.includes(word)) {
          this.exclude.splice(this.exclude.indexOf(word), 1);
        }
      });
  }

  /**
   * Add words to whitelist filter
   * @param {...string} word - Word(s) to add to whitelist.
   */
  removeWords() {
    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));
  }
}

module.exports = Filter;